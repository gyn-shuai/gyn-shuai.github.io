<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>差分矩阵模板</title>
    <url>/2020/05/05/%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>  首先我们定义S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<a id="more"></a>
<p>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1010][1010];</span><br><span class="line">int b[1010][1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m,q;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">	for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">	cin&gt;&gt;a[i][j];</span><br><span class="line">	for(int i&#x3D;0;i&lt;q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x1,y1,x2,y2,c;</span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">		b[x1][y1]+&#x3D;c;</span><br><span class="line">		b[x1][y2+1]-&#x3D;c;</span><br><span class="line">		b[x2+1][y1]-&#x3D;c;</span><br><span class="line">		b[x2+1][y2+1]+&#x3D;c;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i][j]+&#x3D;b[i][j-1]+b[i-1][j]-b[i-1][j-1];</span><br><span class="line">		a[i][j]+&#x3D;b[i][j];</span><br><span class="line">		cout&lt;&lt;a[i][j]&lt;&lt;&#39; &#39;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快排和归并排序模板</title>
    <url>/2020/05/05/%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="快速排序算法模板（以中间为基准点）"><a href="#快速排序算法模板（以中间为基准点）" class="headerlink" title="快速排序算法模板（以中间为基准点）"></a>快速排序算法模板（以中间为基准点）</h2><a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);<span class="comment">//注意这里要以j为基准（或者用i—1，i）防止出现死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<p>两个注意点，起始i和j的赋值要l-1，r+1，第二对子问题处理时用j和j+1或者i-1，i。</p>
<h2 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    merge_sort(q,l,mid);</span><br><span class="line">    merge_sort(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//先拆分，后合并</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;q[j]) t[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> t[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) t[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)   t[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i] = t[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>快速排序 归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>整数划分问题</title>
    <url>/2020/05/05/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="整数划分（一）"><a href="#整数划分（一）" class="headerlink" title="整数划分（一）"></a>整数划分（一）</h2><p>n=m1+m2+…+mi; （其中mi为正整数，并且1 &lt;= mi &lt;= n），则{m1,m2,…,mi}为n的一个划分。<br>如果{m1,m2,…,mi}中的最大值不超过m，即max(m1,m2,…,mi)&lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为q(n,m);<br>根据m和n的关系可将问题划分为：</p>
<a id="more"></a>
<p>1.n或m＜0时， q（n，m）=0；<br>2.n或m等于0时， q（n，m）=1；例如q（n，1）只有n一种情况，q（1，m）也只有1一种情况<br>3.n小于m时，这时q（n，m）=q（n，n），因为由于划分中不可能出现负数。<br>4.n等于m时，q（n，m）=q（n，m-1）+1<br>5.n＞m时，q（n，m）=q（n，m-1）+q（n-m，m）。q（n，m-1）相当于不包含m的划分，q（n-m，m）相当于包含m的划分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==m) <span class="keyword">return</span> q(n,m<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> q(n,m<span class="number">-1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> ans=q(n,n);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200224191216199.png" alt="在这里插入图片描述"></p>
<h2 id="整数划分（二）"><a href="#整数划分（二）" class="headerlink" title="整数划分（二）"></a>整数划分（二）</h2><p>题目：把一个正整数n分成m个正整数的和，有多少种分法？</p>
<p>首先拿6来说，如果要分成3个数相加，可分为 （1,1，4）（1,2，3），（2,2，2）<br>可以看出，可分为一组有1，一组不包含1<br>有1的一组我们把1除掉以便进行递归f（n，m）=f（n-1，m-1）<br>没有1的一组，我们将每个数都减1，（2,2，2）就变成了（1,1，1）也就成为包含1的组合了，递归式就出来了。f（6,3）=f（5,2）+f（3,3）<br>同时我们考虑到当n=0或n＜m时，f（n，m）=0，m=1或者n=m时，f（n，m）=1；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==m||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>,m<span class="number">-1</span>)+f(n-m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f(n,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂 素数筛</title>
    <url>/2020/05/05/%E5%BF%AB%E9%80%9F%E5%B9%82-%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qupow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">		ans=ans*a%m;</span><br><span class="line">		a=a*a%m;</span><br><span class="line">		b=b/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>位运算代码为</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qupow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">		ans=ans*a%m;</span><br><span class="line">		a=a*a%m;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 快速幂将原来0（b）的时间复杂度降为了<strong>O（logb）</strong></p>
<h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><p>首先我们在一般方式求素数时，可以采用以下方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifprime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何用i<em>i&lt;=x; 因假如一个数x=n</em>m，那么n和m必定有一个小于x/2；所以在x/2前不存在能整除x的整数，那么x就一定是素数。<br>在做题中如果需要判断大量的数，如还用上述方法将使效率大大降低，这种情况下可以选择使用素数筛，素数筛也就是在查找数之前将所有的数都判断好是否为素数，存于数组，等输入要判断的数时就可直接通过数组记录来判断出是否为素数。</p>
<h2 id="普通素数筛"><a href="#普通素数筛" class="headerlink" title="普通素数筛"></a>普通素数筛</h2><p>时间复杂度为 O(nloglogn)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> v[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="literal">true</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;i*j&lt;=n;j++)</span><br><span class="line">		v[i*j]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通素数筛有很多数组都被重复遍历，所以可以采用线性筛，也称欧拉筛。<br>欧拉筛的时间复杂度为O （n）</p>
<h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> v[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> prime[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="literal">true</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">	v[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[i]) </span><br><span class="line">		prime[c++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">		    v[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line">		    <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度运算</title>
    <url>/2020/05/05/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="高精度数相加"><a href="#高精度数相加" class="headerlink" title="高精度数相加"></a>高精度数相加</h2><a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A,B 为高精度的数列倒序 </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.size()&lt;B.size()) add(B,A);</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		 t +=A[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.size()) t+=B[i];</span><br><span class="line">		C.push_back(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t) C.push_back(t);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度数相减"><a href="#高精度数相减" class="headerlink" title="高精度数相减"></a>高精度数相减</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t = A[i]-t;</span><br><span class="line">		<span class="keyword">if</span>(t&lt;B.size()) t-=B[i];</span><br><span class="line">		C.puh_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(C.size()&gt;<span class="number">1</span>&amp;&amp;C.back()==<span class="number">0</span>) C.pop_back();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对问题</title>
    <url>/2020/05/07/%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>基础题目：LeetCode 面试题51</p>
<a id="more"></a>
<p>解决逆序对问题常见有两种方法，一种是树状数组，一种是归并排序</p>
<h1 id="归并排序法"><a href="#归并排序法" class="headerlink" title="归并排序法"></a>归并排序法</h1><p>思路：我们在进行普通的归并算法时，在合并时会判断两部分（left和right）中选择最小的放在合并后的数组中，在这里我们只需要以左部分进入合并数组时就说明产生逆序对，且逆序对数目为（j-（mid+1））。（其实以右侧进入为参考点也可以）<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int merge(vector&lt;int&gt;&amp; nums,int l,int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l&gt;&#x3D;r) return 0;</span><br><span class="line">        int mid &#x3D; (l+r)&gt;&gt;1;</span><br><span class="line">        int sum &#x3D; merge(nums,l,mid)+merge(nums,mid+1,r);</span><br><span class="line">        int i&#x3D;l,j&#x3D;mid+1;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;r)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&gt;nums[j]) tmp.push_back(nums[j++]);</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sum+&#x3D;j-mid-1;</span><br><span class="line">                tmp.push_back(nums[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;r) tmp.push_back(nums[j++]);</span><br><span class="line">        while(i&lt;&#x3D;mid) </span><br><span class="line">        &#123;</span><br><span class="line">            sum+&#x3D;j-mid-1;</span><br><span class="line">            tmp.push_back(nums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int p&#x3D;0,q&#x3D;l;p&lt;tmp.size();p++,q++) nums[q]&#x3D; tmp[p];</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p>
<p>单点更新 update(i, v)： 把序列 ii 位置的数加上一个值 v，<br>区间查询 query(i)： 查询序列 [1 。。。 i][1⋯i] 区间的区间和，即 i 位置的前缀和<br>修改和查询的时间代价都是 O(logn)，其中 n 为需要维护前缀和的序列的长度。</p>
<p>思路：我们从后往前的遍历数列，当遍历到该点时其query（i-1）（i-1的前缀和）就是该点后小于它的数，也就是该点组成的逆序对。注意：如果数据量大，需要离散化一下</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line">int query(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int ans  &#x3D;0;</span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans +&#x3D; a[x];</span><br><span class="line">        x -&#x3D; lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125; </span><br><span class="line">void update(int x)  &#x2F;&#x2F;这题所有要加的值都为1</span><br><span class="line">&#123;</span><br><span class="line">    while(x&lt;&#x3D;n)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x]++;</span><br><span class="line">        x +&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int reversePairs(vector&lt;int&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int ans &#x3D;0;</span><br><span class="line">    for(int i&#x3D;nums.size()-1;i&gt;&#x3D;0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+&#x3D;query(nums[i]-1);</span><br><span class="line">        update(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶题目"><a href="#进阶题目" class="headerlink" title="进阶题目"></a>进阶题目</h1><p>计蒜客 青出于蓝胜于蓝</p>
<p>武当派一共有 n 人，门派内 n 人按照武功高低进行排名，武功最高的人排名第 1，次高的人排名第 2，… 武功最低的人排名</p>
<p>第 n。现在我们用武功的排名来给每个人标号，除了祖师爷，每个人都有一个师父，每个人可能有多个徒弟。</p>
<p>我们知道，武当派人才辈出，连祖师爷的武功都只能排行到 pp。也就是说徒弟的武功是可能超过师父的，所谓的青出于蓝胜于蓝。</p>
<p>请你帮忙计算每个人的所有子弟（包括徒弟的徒弟，徒弟的徒弟的徒弟….）中，有多少人的武功超过了他自己。</p>
<p>输入格式<br>输入第一行两个整数 n, p(1 ≤ n ≤ 100000, 1 ≤  p ≤ n) n , p (1≤n≤100000,1≤p≤n)。</p>
<p>接下来 n-1 行，每行输入两个整数 u, v(1 ≤ u, v ≤ n)u , v  (1≤u,v≤n)，表示 u 和 v 之间存在师徒关系。</p>
<p>输出格式<br>输出一行 n 个整数，第 i 个整数表示武功排行为 i 的人的子弟有多少人超过了他。</p>
<p>行末不要输出多余的空格。</p>
<p>思路：本题其实就是让你求一棵树中每个节点的子节点中小于本身的数的个数，也就是求逆序对，但这题要求root的逆序对，所以要用dfs来求出每个节点的个数。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,root;</span><br><span class="line">vector&lt;int&gt; a[100010];</span><br><span class="line">int c[100010],ans[100010];</span><br><span class="line">bool v[100010];</span><br><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">int query(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        res +&#x3D; c[x];</span><br><span class="line">        x -&#x3D; lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">void add(int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(x&lt;&#x3D;n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]++;</span><br><span class="line">        x +&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    v[x]&#x3D; true;</span><br><span class="line">    ans[x]&#x3D;query(x);</span><br><span class="line">    add(x);</span><br><span class="line">    for(int i&#x3D;0;i&lt;a[x].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp &#x3D; a[x][i];</span><br><span class="line">        if(!v[tmp])  &#x2F;&#x2F;判断是否访问了结点</span><br><span class="line">            dfs(tmp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] &#x3D; query(x-1)-ans[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;root;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int p,q;</span><br><span class="line">        cin&gt;&gt;p&gt;&gt;q;  &#x2F;&#x2F;这里用图来表示</span><br><span class="line">        a[p].push_back(q);</span><br><span class="line">        a[q].push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;</span><br><span class="line">      cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
